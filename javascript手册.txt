1.删除数组元素
	delete arr[index]
	也可以删除对象的属性
	删除变量
2.Math.pow(i, y);
	i的y次方
3.arr.shift()
	去掉数组的第一个元素
  arr.forEach()
     遍历数组元素
     eg:
     [1, 2 ,3, 4].forEach(alert);

  IE6-IE8
  if (typeof Array.prototype.forEach != "function") {
	  Array.prototype.forEach = function (fn, context) {
	    for (var k = 0, length = this.length; k < length; k++) {
	      if (typeof fn === "function" && Object.prototype.hasOwnProperty.call(this, k)) {
	        fn.call(context, this[k], k, this);
	      }
	    }
	  };
	}
     ES5 isArray判断对象是不是数组
     eg:
     	Array.isArray("NO U")
     	>> false

     	Array.isArray(["NO", "U"])
     	>> true
     ES3兼容性处理
     	Object.prototype.toString.apply(value) === '[object Array]'
     增补：arr.map(callback,[ thisObject]);
  arr.map(function(value, index, array){},[ thisObject]);
  	映射一个新的数组
  	eg:
  	var arr = [1,2,3,4];
  	var arr2 = arr.map(function(item){
  		return item * item;
  	});
  	//arr2 = [1,4,9,16];

  IE6-IE8
  if (typeof Array.prototype.map != "function") {
	  Array.prototype.map = function (fn, context) {
	    var arr = [];
	    if (typeof fn === "function") {
	      for (var k = 0, length = this.length; k < length; k++) {
	         arr.push(fn.call(context, this[k], k, this));
	      }
	    }
	    return arr;
	  };
   }

  	增补：arr.filter(callback,[ thisObject]);
  	过滤一个数组，符合的留下，不符合的剔除掉
  	var users = [
	  {name: "张含韵", "email": "zhang@email.com"},
	  {name: "江一燕",   "email": "jiang@email.com"},
	  {name: "李小璐",  "email": "li@email.com"}
	];

	var zhangEmail = users
	.map(function (user) { return user.email; })
	.filter(function(email) {  return /^zhang/.test(email); });
	console.log(zhangEmail.join(", "));

	兼容性：
	if (typeof Array.prototype.filter != "function") {
	  Array.prototype.filter = function (fn, context) {
	    var arr = [];
	    if (typeof fn === "function") {
	       for (var k = 0, length = this.length; k < length; k++) {
	          fn.call(context, this[k], k, this) && arr.push(this[k]);
	       }
	    }
	    return arr;
	  };
	}

  	增补：arr.some(callback,[ thisObject]);
  	数组中的某一个值
  	eg:
  	var scores = [5, 8, 3, 10];
	var current = 7;

	function higherThanCurrent(score) {
	  return score > current;
	}

	if (scores.some(higherThanCurrent)) {
	  alert("朕准了！");
	}

	IE6-IE8
	if (typeof Array.prototype.some != "function") {
	  Array.prototype.some = function (fn, context) {
		var passed = false;
		if (typeof fn === "function") {
	   	  for (var k = 0, length = this.length; k < length; k++) {
			  if (passed === true) break;
			  passed = !!fn.call(context, this[k], k, this);
		  }
	    }
		return passed;
	  };
	}

	增补：arr.every()
	与some正好相反
	eg：
	var scores = [5, 8, 3, 10];
	var current = 7;

	function higherThanCurrent(score) {
	  return score > current;
	}

	if (scores.every(higherThanCurrent)) {
	  alert("朕准了！");
	} else {
	  console.log("来人，拖出去斩了！");
	}

	IE6-IE8
	if (typeof Array.prototype.every != "function") {
	  Array.prototype.every = function (fn, context) {
	    var passed = true;
	    if (typeof fn === "function") {
	       for (var k = 0, length = this.length; k < length; k++) {
	          if (passed === false) break;
	          passed = !!fn.call(context, this[k], k, this);
	      }
	    }
	    return passed;
	  };
	}

	增补：array.indexOf(searchElement[, fromIndex])
		返回整数索引值，如果没有匹配（严格匹配），返回-1. fromIndex可选，表示从这个位置开始搜索，若缺省或格式不合要求，使用默认值0
		eg:
		var data = [2, 5, 7, 3, 5];
		console.log(data.indexOf(5, "x")); // 1 ("x"被忽略)
		console.log(data.indexOf(5, "3")); // 4 (从3号位开始搜索)
		console.log(data.indexOf(4)); // -1 (未找到)
		console.log(data.indexOf("5")); // -1 (未找到，因为5 !== "5")

	兼容性：
		if (typeof Array.prototype.indexOf != "function") {
		  Array.prototype.indexOf = function (searchElement, fromIndex) {
		    var index = -1;
		    fromIndex = fromIndex * 1 || 0;

		    for (var k = 0, length = this.length; k < length; k++) {
		      if (k >= fromIndex && this[k] === searchElement) {
		          index = k;
		          break;
		      }
		    }
		    return index;
		  };
		}
	增补：array.lastIndexOf(searchElement[, fromIndex])
		lastIndexOf方法与indexOf方法类似：
		只是lastIndexOf是从字符串的末尾开始查找，而不是从开头。还有一个不同就是fromIndex的默认值是array.length - 1而不是0.
		eg:
		var data = [2, 5, 7, 3, 5];
		console.log(data.lastIndexOf(5)); // 4
		console.log(data.lastIndexOf(5, 3)); // 1 (从后往前，索引值小于3的开始搜索)
		console.log(data.lastIndexOf(4)); // -1 (未找到)

	IE6:
	if (typeof Array.prototype.lastIndexOf != "function") {
	  Array.prototype.lastIndexOf = function (searchElement, fromIndex) {
	    var index = -1, length = this.length;
	    fromIndex = fromIndex * 1 || length - 1;

	    for (var k = length - 1; k > -1; k-=1) {
	        if (k <= fromIndex && this[k] === searchElement) {
	            index = k;
	            break;
	        }
	    }
	    return index;
	  };
	}

	增补：array.reduce(callback[, initialValue])
		array.reduce(function (previous, current, index, array){}[, initialValue])
		迭代，递归
		callback函数接受4个参数：之前值、当前值、索引值以及数组本身
		initialValue参数可选，表示初始值。
			指定，则当作最初使用的previous值；
			缺省，则使用数组的第一个元素作为previous初始值，同时current往后排一位，相比有initialValue值少一次迭代。
		eg:
		var sum = [1, 2, 3, 4].reduce(function (previous, current, index, array) {
		  return previous + current;
		});
		console.log(sum); // 10

		说明：
		因为initialValue不存在，因此一开始的previous值等于数组的第一个元素。
		从而current值在第一次调用的时候就是2.
		最后两个参数为索引值index以及数组本身array.

		以下为循环执行过程：
		// 初始设置
		previous = initialValue = 1, current = 2

		// 第一次迭代
		previous = (1 + 2) =  3, current = 3

		// 第二次迭代
		previous = (3 + 3) =  6, current = 4

		// 第三次迭代
		previous = (6 + 4) =  10, current = undefined (退出)

		有了reduce，我们可以轻松实现二维数组的扁平化：
		var matrix = [
		  [1, 2],
		  [3, 4],
		  [5, 6]
		];

		// 二维数组扁平化
		var flatten = matrix.reduce(function (previous, current) {
		  return previous.concat(current);
		});

		console.log(flatten); // [1, 2, 3, 4, 5, 6]

		IE6-IE8:
		if (typeof Array.prototype.reduce != "function") {
		  Array.prototype.reduce = function (callback, initialValue ) {
		     var previous = initialValue, k = 0, length = this.length;
		     if (typeof initialValue === "undefined") {
		        previous = this[0];
		        k = 1;
		     }

		    if (typeof callback === "function") {
		      for (k; k < length; k++) {
		         this.hasOwnProperty(k) && (previous = callback(previous, this[k], k, this));
		      }
		    }
		    return previous;
		  };
		}

		增补：array.reduceRight(callback[, initialValue])
			reduceRight跟reduce相比，用法类似：
			差异在于reduceRight是从数组的末尾开始实现
			eg:
			var data = [1, 2, 3, 4];
			var specialDiff = data.reduceRight(function (previous, current, index) {
			  if (index == 0) {
			    return previous + current;
			  }
			  return previous - current;
			});

			console.log(specialDiff); // 0
			循环步骤：
			// 初始设置
			index = 3, previous = initialValue = 4, current = 3

			// 第一次迭代
			index = 2, previous = (4- 3) = 1, current = 2

			// 第二次迭代
			index = 1, previous = (1 - 2) = -1, current = 1

			// 第三次迭代
			index = 0, previous = (-1 + 1) = 0, current = undefined (退出)

			兼容性：
			if (typeof Array.prototype.reduceRight != "function") {
			  Array.prototype.reduceRight = function (callback, initialValue ) {
			    var length = this.length, k = length - 1, previous = initialValue;
			    if (typeof initialValue === "undefined") {
			        previous = this[length - 1];
			        k--;
			    }
			    if (typeof callback === "function") {
			       for (k; k > -1; k-=1) {
			          this.hasOwnProperty(k) && (previous = callback(previous, this[k], k, this));
			       }
			    }
			    return previous;
			  };
			}

4.每个标签都是一个对象{id:"bbc", title:"title", onClick:function(){..}}
5.h1
{
	tagName:"h1",
	innerHTML:"todo"
}
6.undefined有可能像变量一样
	1.var undefined = 123;
	 var b = undefined;
	 alert(b);	//output  undefined

[] instanceof Array
7.判断数据类型
	function isType(param){
		//1.判断是不是字符串对象
		if(typeof param === 'string' && param.constructor == String){
			return "String";
		}

		//2.判断是不是数字对象
		if(typeof param === 'number' && param.constructor == Number){
			return "Number";
		}

		//3.判断是否为数组类型
		if(typeof param === 'object' && param.constructor == Array){
			return "Array";
		}

		//4.判断是否是日期类型
		if(typeof param === 'object' && param.constructor == Date){
			return "Date";
		}

		//5.判断是否为函数
		if(typeof param === 'function' && param.constructor == Function){
			return "Function";
		}

		//6.判断是否为普通的对象
		if(typeof param === 'object' && param.constructor == Object){
			return "Object";
		}
	}
8.Number.POSITIVE_INFINITY
   Number.NEGATIVE_INFINITY
9.isFinite()
 	是不是有穷值
10.isNaN()
 	是非数字吗
11.\
	换行转义符号,可以写多行
	var str = "bbc\
	ddb\
	ddb";
12.基模式[默认基10]
	(255).toString(16);	FF
	(0xFF).toString();	255
13.parseInt(number, 16);
	解析顺序是从左到右
	0189  --->  01
	parseInt(12bc)   ---> 12
14.
	返回true
	!null
	!0
	!undefined
	!""
	!NaN
	所有的对象转化为boolean时都是true
	包括new Boolean(false), new Boolean();

	返回false
	!" "
	!true
	!(new Object())
	!-1
15.终止整个循环
	var iNum = 0;
	outermost:
	for(var i=0; i<10; i++){
		for(var j=0; j<10; j++){
			if(i == 5 && j == 5){
				break outermost;
			}
			iNum++;
		}
	}
	console.log(iNum++);
16.with语法[运行及其缓慢，deprecated]
17.正则表达式
	神器：https://regexper.com/
	var rule = new RegExp("模式字符串"， "标志");
	var rule = /模式字符串/标志;
	1>rule.test(被检测的字符串);
	2>"被检测的字符串".indexOf("word");
	注：rule = /[a-z]/i;		等价于
		rule = /[a-zA-Z]/;
		\w   等价于   /a-zA-Z0-9_/;		注：字母、数字、下划线

	增补：string.indexOf(searchString, position)

	3>rule.exec(被检测的字符串);	[返回一个符合的数组]
	4>"被检测的字符串".replace(/正则表达式/g, '#');
	注：
		"    fdasfsaas  ".replace(/^\s+/,"").replace(/\s+$/,"");
		"    fdasfsaas  ".replace(/(^\s+)|(\s+$)/g,"")
		"    fdasfsaas  ".replace(/^\s*(.+?)\s*$/, '$1');
		分组交换：
		var rule = /(\d+)-(\d+)/;
		"23-45".replace(rule,'$2-$1');
	eq:	 /^\s*(.+?)\s*$/.exec("    fdasfsaas  ")[1];

	5>search与indexOf差不多，功能更强大,可以用正则表达式
	"被检测的字符串".search(/正则表达式/);	g是没有用的，都是返回的第一个适配的
	6>match与exec方向相反,
		"被检测的字符串".match(rule);
	7>非贪婪
		var rule = /(\d+?)/;
	7.1>忽略分组
		不希望捕获某些分组，在分组内加上?:
		(?:Byron).(ok)
	8>非捕获
		var rule = /(\d+)(?:[a-z])/;
	9>反向引用
		var rule = /(\d{3})-\1/;
	10>正向前瞻(条件过滤器)[捕获特定字符之前的字符][后边为前的方向，没有反向后顾(可以模拟出来)]
		正则表达式从文本头部向尾部开始解析，文本尾部方向，成为"前"
		前瞻就是在正则表达式匹配到规则的时候，向前检查是否符合断言
		正向前瞻		exp(?=assert)
		负向前瞻		exp(?!assert)
		var s = "Ubuntu 8.10 is a good OS. Ubuntu 9.10 xxx";
		var rule = /([a-z]+)(?=\s+8\.10)/i;
		s.replace(rule, 'Debian');
		var rule = /[a-z]+(\s+8\.10)/gi;
		s.replace(rule, 'Debian$1');
	11>边界匹配字符
	\b   单词边界
	\B   非单词边界
	12>对象属性[只读]
		•global:是否是全文搜索，默认false
		•ingore case:是否大小写敏感，默认是false
		•multiline:多行搜索，默认值是false
		•lastIndex:是当前表达式匹配内容的最后一个字符的下一个位置[有全局属性g时才有效，其他情况默认为0]
		•source:正则表达式的文本字符串
		•index匹配字符串的开始位置
	13>exec
	说明：
		1.没有g时，循环次数没有限制，每次结果都一样
		2.有g时，每次结果可能不一样
		3.没有匹配的文本则返回null,否则返回一个结果数组
		4.index	声明匹配文本的第一个字符的位置
		5.input	存放被检索的字符串string(就是被匹配的字符串)

	var reg3 = /\d(\w)\d/;
	var reg4 = /\d(\w)\d/g;
	var ts = '1a2b3c4d5e';

	var ret = reg3.exec(ts);

	while(ret = reg4.exec(ts)){
		console.log(reg4.lastIndex + '\t' + ret.index + '\t' + ret.toString());
	}

	14>String.prototype.search(reg)
	•方法返回第一个匹配结果index，查找不到返回-1
	•不执行全局匹配，它将忽略标志g，并且总是从字符串的开始进行检索

	15>String.prototype.match(reg)
	•match()方法将检索字符串，以找到一个或多个regexp匹配的文本
	•regexp是否具有标志g对结果影响很大

	15.string.replace(正则表达式, replaceFun);
	function 参数含义
	function会在每次匹配替换的时候调用，有四个参数
	1.匹配字符串
	2.正则表达式分组内容，没有分组则没有该参数
	3.匹配钉在字符串中的index
	4.原字符串
	eg:
	'a1b2c3d4e5'.replace(/(\d)(\w)(\d)/g, function(match, group1, group2, group3, index, origin){
		console.log("match:   " + match);
		console.log("group1:" + group1);
		console.log("group2:" + group2);
		console.log("group3:" + group3);
		console.log("index:" + index);
		console.log("origin:" + origin);
	});


18.引用类型
	1>创建对象的时候如果没有参数可以省略括号
		var obj = new Object;
		var date = new Date;
	2>属性
		constructor,对象的引用(指针)，指向原始的Object()函数
		prototype,默认返回Object对象的一个实例
		hasOwnProperty(property),判断对象是否含有某个特定的属性，属性名必须为string类型
		isPrototype(object),判断该对象是否为另一个对象的原型
		propertyIsEnumerable(property),判断给定的属性是否可以用for...in语句进行枚举
		toString(),返回对象的原始字符串表示。
		valueOf(),返回最适合该对象的原始值。大部分与toString()返回值相同。
	3>数字
		var n = 68,
		n.toFixed(2);	注：保留2位小数
		var n = 68.0000000000000000000000000009;
		n.toPrecision(3);	注：只保留3位数
19.函数
	(a = Math).sqrt(2);
	()作用，将括号中的表达式求值返回给上下文

	1>arguments
	类似数组，有length属性，可以用下标访问arguments[index]
	arguments.callee调用的是函数本身
		function fn(){
			alert(arguments.callee);
		}
		function add(n){
			return n>1?n +  arguments.callee(n-1):1;
		}
	2>length,就是函数参数的个数
	3>fn.caller，调用这个函数的函数
20.闭包
	1>返回给外部一个函数的引用
21.继承
	function Demo(){
		this.toString = 123;
	}
	Demo.prototype={//139
		name:"CJ",
		getName:function(){
			return this.name;
		}
	}/**把一个对象改变为另外一个对象**/
	Demo.prototype.name="CJ";/**为对象添加属性**/146
	var d=new Demo();
	console.log(d.getName());
	注：1>2种赋值方式意义不一样！！！
		2>创建对象和添加属性的没有顺序要求，只要在调用之间就可以
		比如：把139和146换行，效果依然一样
		3>添加属性后，所有的实例都会继承这个属性[在类上添加]
		4>指向另一个对象后，所有的实例并不会继承这个属性[在对象上添加]
		5>对象之间的继承不能传参数[如果传，1.只会别执行一次2.必须在调用之前]
	比如：
		function DemoA(name){
			this.name = name;
		}
		function DemoB(){
		}
		DemoB.prototype = new DemoA("CJ");//只能执行一次[就是传入的值是固定的值]
		var d = new DemoB();
		console.log(d.name);
		console.log(d.name);
		注：就是不能添加参数
		6>有参数的继承是这样子的[二]
		function DemoA(name, age){
			this.name = name;
			this.age = age;
		};
		function DemoB(name, age){
			this.DemoA = DemoA;
			this.DemoA(name, age);
		}
		var d = new DemoB('CJ', 18);
		console.log(d.name);
		7>有参数的继承还可以是这样子的[三]
		function DemoA(name, age){
			this.name = name;
			this.age = age;
		}
		var obj = {};
		DemoA.call(obj, 'CJ', 18);//DemoA的控制权交给obj
		DemoA.apply(obj, ['CJ', 18]);//传递的参数是个数组
		console.log(obj.name);

		Math.min.apply(null, [2,1,6,8,9]);//借用Math的方法
		7>继承方法
		[].join.call(arguments, '\n');
		8>ClassName.isPrototypeof(instantce)
		9.继承已有属性
		function DemoA(){
			this.name = "CJ";
		}
		function DemoB(){
		}
		子类.prototype = new 父类;//不能传参数
22.BOW,DOM
	1>window.history.go(-1)
	2>window.history.forward()
	3>window.history.back()
	4>JS弹出的窗口可以用JS关闭，而没有提示
	5>window.status="123"
	6>window.location.reload()
	7>setTimeout一般是用匿名函数
	8>window.location === document.location[他们引用的是同一个对象]
		console.dir(location);//遍历location对象的所有属性
		eg:
		"http://image.baidu.com/channel?c=宠物#宠物"
		hash	1.#最后的内容		eg:"#宠物"
		host    2.主机名			eg:"image.baidu.com"
		hostName   3.主机名			eg:"image.baidu.com"
		port       4.端口			eg:""
		pathName   5.除去host之外的名字		eg:"/channel"
		protocol	"http:"
		search     eg:"?c=宠物"
		href       eg:"http://image.baidu.com/channel?c=宠物#宠物"

		常用：
		window.location.href="your url";	//有历史记录
		window.location.reload(true);//强制刷新
		window.location.reload();//缓存刷新
		window.location.replace("you url");		//没有历史记录
	9>Navigator
23.frame
	1>contentWindow	返回内嵌的网页窗口对象
	2>window.parent返回父窗口
24.浏览器检测
	主要以下2种：
	1>userAgent字符串检测
	2>对象检测
25.DOM
	1>label for属性 document.getElementsByTagName("label")[0].htmlFor
	2>文档根节点
	document.documentElement //就是html标签
26.Form
	form.onreset = function(){}  //此方法被废弃
	checkboxRadio[0].checked;  //radio,checkbox是否被选中
	checkboxRadio[0].defaultChecked;	//是否是默认选中
	textInput.select();	//选中单选框中的文字
	textInput.onSelect() = function(){}		//选中事件
	select.selectedIndex;		//被选中的option的下标
	TODO:

	$("#libfiles").off("mouseenter", "li");
	$("#libfiles").on("mouseenter", "li", function(e){
		var text = $(this),
			range,
			selection;

		if(!text.length) return;
		text = text[0];

		if (document.body.createTextRange) {
			range = document.body.createTextRange();
			range.moveToElementText(text);
			range.select();
		} else if (window.getSelection) {
			selection = window.getSelection();
			range = document.createRange();
			range.selectNodeContents(text);
			selection.removeAllRanges();
			selection.addRange(range);
		}
	});

27.table
	table.caption	//获取caption节点[唯一]
	table.tHead		//获取head节点[唯一]
	table.tFoot		//获取foot节点[唯一]
	table.tBodies		//获取全部的body

	//行和单元格的操作
	table.rows	//返回所有的行
	table.rows[rowIndex].cells	//返回所有的行
	oneRow.rowIndex	//获取下标
	oneRow.sectionRowIndex	//当前tbody中的下标，不是全局的
	oneCell.cellIndex	//获取单元下标
	//表头的操作
	table.createCaption();	//没有的创建新表头，有的返回已有的表头
	table.createTHead();
	table.createTFoot();

	table.deleteCaption();
	table.deleteTHead();
	table.deleteTFoot();

	table.insertRow(rowIndex);
	row.insertCell(cellIndex);

	table.deleteRow(rowIndex);
	row.deleteCell(cellIndex);
28.事件
   1>mouse事件
   	属性：
   		button：W3C规定,0:左键，1:滚轮，2:右键
   				IE规定,1:左键，4:滚轮，2:右键
   		clientX:客户端[参照点page]可视区域的X坐标
   		clientY:客户端可视区域的Y坐标
   		注：相对于是可视页面
   		----------------------------------------------------------------------------------
   		screenX[全兼容]:相对于显示器屏幕的X坐标
   		screenY[全兼容]:相对于显示器屏幕的Y坐标
   		iphone中相当于pageX，pageY，因为手机上window区域和文档区域是一样的
   		----------------------------------------------------------------------------------
   		x(ie):相对于父元素的X坐标		jQuery.position().left;
   		y(ie):相对于父元素的Y坐标		jQuery.position().top;
   		----------------------------------------------------------------------------------
   		offsetX(ie):绑定事件对象的X坐标原点[参照点：绑定事件的对象原点]		jQuery:offset().left;
   		layerX(W3C)
   		offsetY(ie):事件对象的Y坐标		jQuery:offset().top;
   		layerY(W3C)
   		注：offset更好用一些，高级浏览器也支持
   			layer只有对象有定位信息时才好用，比如:position:absolute
   		----------------------------------------------------------------------------------
   		pageX(W3C):鼠标相对于页面的X坐标
   		pageY(W3C):鼠标相对于页面的Y坐标
   		注:相对于是整个的页面
   			IE下边需要自己计算
   		----------------------------------------------------------------------------------
   		obj.offsetParent.offsetLeft
   		obj.offsetParent.offsetTop
   	2>key事件
   	属性：
   		altKey:true/false
   		ctrlKey:true/false
   		shiftKey:true/false
   		keyCode:
   			1>>kepress事件，表示按钮的unicode编码，不是字符键，属性值为0
   			2>>keydown/keyup,表示按键的数
   		charCode(W3C)：对应keypress的1>>描述，这个区分大小写
   			可能不兼容用keyCode内容代替
   			String.fromCharCode();将其转换成实际的字符串
   	3>其他属性
   		srcElement(IE):引起事件的元素
   		target(W3C)
   		----------------------------------------------------------------------------------
   		fromElement(IE):mouseover,鼠标所离开的元素
   		toElement(IE):mouseout,鼠标所进入的元素
   		relatedTarget(W3C):mouseover/mouseout
   		----------------------------------------------------------------------------------
   		repeat(IE):不断触发keydown事件，为true,否则false
   		----------------------------------------------------------------------------------
   		returnValue(IE):设为false表示取消事件的默认动作
   		preventDefault(W3C):
   		----------------------------------------------------------------------------------
   		type:事件名称,不带on前缀
   		----------------------------------------------------------------------------------
   		cancelable(W3C):true表示默认动作可取消(用preventDefault方法取消)
   		cancelBubble(IE):设置为true取消冒泡事件
   		stopPropagation(W3C):取消事件冒泡
   		bubbles(W3C):返回true表示事件是冒泡类型
   		----------------------------------------------------------------------------------
   		eventPhase(W3C):
   			Event.CAPTURING_PHASE(捕获阶段)	值为1
   			Event.AT_TARGET(在目标对象上) 值为2
   			Event.BUBBLING_PHASE(冒泡阶段)	值为3
   		----------------------------------------------------------------------------------
   		timeStamp(W3C):返回一个时间戳
   		----------------------------------------------------------------------------------
   	4>绑定事件
   		addEventListener(evtType, fn, isCapture);
   		removeEventListener(evtType, fn, isCapture);
   		attachEvent("on" + evtType, fn);
   		detachEvent("on" + evtType, fn);
   		注：
   		1>>IE中fn的this默认指向的是window[this对象冒充]
   		2>>IE中同一个函数注册到同一个对象上可以多次[自己编写处理]
   		3>>IE中存在内存泄露问题
29.样式
	1>oDiv.style	//返回的是一个对象
		返回的是设置的style样式
		eg: style="width:100px;height:100px;border-color:#fff"
		console.log(oDiv.style.width);	//100px
		console.log(oDiv.style.borderColor)	//#fff
		oDiv.style.borderLeftColor;
		oDiv.style.border = '1px solid red';
		oDiv.style.backgroundColor;		//颜色值FF返回的始终是RGB
		oDiv.style.cssText;	//返回浏览器设置的style[结果是浏览器渲染后的结果]
			oDiv.style.cssText="width:20px;height:10px;display:bolck";		把多个样式进行合并提高了浏览器渲染的效率
	注：返回的只是内联样式设置的样式
	作用：用来设置值
	2>实际的样式
		IE. oDiv.currentStyle
			oDiv.currentStyle.width;
			oDiv.currentStyle.height;
		W3C:getComputedStyle(oDiv, null);	//null没有实现
			getComputedStyle(oDiv, null).width
			getComputedStyle(oDiv, null).borderLeftColor;  //复合属性要写的详细些
			getComputedStyle(oDiv, null).backgroundColor;
	3>document.styleSheets;	//样式文件的伪数组
		属性：
		type:text/css
		href:链接地址
		cssText(IE):样式表中规则的文本形式
		rules(IE),cssRules(W3C):对应样式表里所有规则的集合[都是数组的形式]
		Rule对象属性:
		selectText:选择符
		style,可以读取和设置CSS规则，并且由cssText属性和内联样式的方式一样
		eg:
			rules[ruleIndex].style.width;
			rules[ruleIndex].style.width = "500px";	//样式比较隐蔽，查看代码是看不出来的
	4>修改样式表
		FF:insertRule(cssText, cssIndex);
			eg:
				document.styleSheets[0].insertRule("body{color:blue;}", 1);
		IE:addRule(selector, cssText, cssIndex);
			eg:
				document.selector[0].addRule("body", "color:blue", 1);
		FF:deleteRule(cssIndex)
			eg:
				document.styleSheets[0].deleteRule(1);
		IE:removeRule(cssIndex);
			eg:
				document.styleSheets[0].removeRule(1);
	5>特殊的属性值
		float:
		element.style.cssFloat(W3C)
		element.style.styleFloat(IE)
30.定位
	1>oDiv.clientWidth,	oDiv.clientHeight[全兼容][内容区域的宽度、高度，不包括边框，content_width+padding_left+padding_right, content_height+padding_top+padding_bottom][裸的宽度和高度]
		注：1>>返回的宽度和高度[此值比较准确, CSS中给定值后才有效]
			2>>返回的是屏幕上可以看到的大小，有滚动条比实际值小
	2>oDiv.scrollWidth, oDiv.scrollHeight[IE8+，Opera11+][滚动的高度+可视区域的高度]
		注：返回的是实际的宽度和高度[包括隐藏的部分]
		1.没有隐藏部分，等价于clientWidth, clientHeight
		2.有滚动条时，scrollHeight = scrollTop + clientHeight

	3>oDiv.offsetWidth, oDiv.offsetHeight[全兼容]
		注：在[页面中]所占实际的大小[width + padding + border][不受内部子元素大小的影响，只和本身元素大小的设定有关]
		悟：可以计算滚动条的宽度offsetWidth - border*2 - clientWidth

		//获取滚动条的宽度
		function getScrollbarWidth(){
			var el = document.createElement('p');
			styles = {
				width:'100px',
				height:'100px',
				overflowY:'scroll'
			};
			for(var i in styles){
				el.style[i] = styles[i];
			}
			document.body.appendChild(el);
			var scrollbarWidth = el.offsetWidth - el.clientWidth;
			el.remove();
			return scrollbarWidth;

		}
	4>窗口视口的大小
		获取window窗体的内部宽度，不包括用户界面元素，比如窗框
		W3C:window.innerWidth, window.innerHeight[IE9+][只读]
		注：不包括地址栏等，只是显示内容的视口的高度

		可视区域的高度：
		window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight

		clientWidth和clientHeight[包括padding+content][不包括滚动条][在页面中所占的宽度除去滚动条的宽度]
		IE:document.documentElement.clientWidth, document.documentElement.clientHeight
		document.body.clientWidth,document.body.clientHeight[IE7之前的版本]
	5>oDiv.clientLeft, oDiv.clientTop[全兼容][俗：左边框的宽度，上边框的宽度]
		注：只能是左边和上边的宽度
		内容区域相对于元素左上角的位置，即border_left_width,	border_top_width
	6>oDiv.offsetLeft, oDiv.offsetTop[全兼容]
		1.表示相对于最近的祖先定位元素（CSS position 属性被设置为 relative、absolute 或 fixed 的元素）的左右偏移值
		2.position不是static的元素
		注：1>>返回距离父元素左边和高度的距离
			2>>必须设置了定位才能计算[即offsetParent]
			3>>包括margin + 父元素的padding + 父元素的borderWidth[完全属于自己的部分距离完全属于父元素的部分]
			注:offsetParent取最近的那个父级元素
		在IE6/7中
		offsetLeft = (offsetParent的padding-left) + (当前元素的margin-left)
		在IE8/9/10及Chrome中
		X offsetLeft = (offsetParent的margin-left) + (offsetParent的border宽度) + (offsetParent的padding-left) + (当前元素的margin-left)X
		就是距离offsetParent边框的 距离

		jQuery部分
		.position()
		相对于offsetParent的当前坐标值
		{left:相对于offsetParent元素左侧的距离，top:相对于offsetParent元素顶部的距离}
	7>oDiv.scrollLeft, oDiv.scrollTop[全兼容][可读可写]
		释义:当元素其中的内容超出其宽高的时候，元素被卷起的高度和宽度[指的是拥有滚动条的元素而非子元素]
		注：有滚动条的元素的滚动距离
		eg:	outer, inner，只有outer的这个属性才有意义

		jQuery部分
		.scrollLeft() || .scrollTop()
		释义1:相对于水平滚动条左边的距离，滚动条居左或元素不能滚动，值为0
		释义2:相对于垂直滚动条顶部的距离，滚动条居顶或元素不能滚动，值为0
	8>clientX, clientY[全兼容]
		释义:相对于浏览器(可视区域左上角0,0)的坐标
		返回发生时鼠标在视口中的坐标
		鼠标相对于window的偏移
		IOS上=pageX，pageY
	9>layerX, layerY/offsetX, offsetY[兼容性很糟糕]
		返回发生时鼠标相对于目标对象的坐标
		Opera支持addEventListener,但不支持layerX, layerY
		bug解释：
			在IE7以及以下浏览器下，只有当当前目标元素为offsetParent是才计算坐标值，否则，它就会拿当前目标元素的offsetParent来计算。还有，当发现元素应用了position: relative后，IE会去寻找下一个offsetParent来计算offsetY，但又不是offsetX。是的，读两次，很蛋疼吧！
	10>pageX, pageY(W3C)[IE9+]
		返回的是相对于页面的坐标
		鼠标相对于document的坐标
	eg:
		拖动实例思路
		元素必须有定位属性
		1>>mousedown
			记录元素左上角位置
			var startLeft = layerX/offsetX
			var startTop = layerY/offsetY
		2>>mousemove
		3>>mouseup
		注：
			1>>可能会出现禁止光标,可以禁止默认事件
			2>>拖动的情况比较复杂，建议用第三方脚本
	11>$("#logo_bbc")[0].scrollIntoView();
		跳转到可见区域内
		eg:window.scrollTo(0, 0);
	12>pageXOffset,pageYOffset[IE9+]
		表示整个页面滚动的像素值（水平方向的和垂直方向的）
	 	eg:
	 	window.pageXOffset
		window.pageYOffset
31.cookie
	1>document.cookie
		name1=value1;name2=value2;name3=value3
	2>typeof document.cookie
		string
	3>只能存储url中的字符类型[用encodeURI, encodeURIComponent编码]
	4>cookie是用网站来区分的
	5>一次只能赋一个值
		document.cookie = "cookieName=cookieValue";
		document.cookie = "cookieName2=cookieValue2";
	6>expires
		document.cookie = "cookieName2 = cookieName2;expires=" + d.toGMTString();
32.错误处理
	try{}catch(e){}finaly{}
	e.message	错误信息
33.动画
	1>清除文本选中状态
		if(document.selection && document.selection.empty){
			document.selection.empty();	//IE
		}else if(window.getSelection){
			window.getSelection().removeAllRanges();	//FF
		}
	2>IE当鼠标移除窗口之后仍能捕获事件
		if(curObj.setCapture){
			curObj.setCapture(true);
		}
	3>IE释放捕获
		if(curObj.releaseCapture){
			curObj.releaseCapture(true);
		}
	4>浏览器检测
		1>> Opera
			window.opera+"" == [window opera]
		2>>IE
			window.ActiveXObject
			navigator.userAgent.indexOf("msie");
		3>>Firefox
			typeof document.mozHidden != 'undefined'
	5>好看的颜色值
		teal
34.拖放
	TODO[作为一个封装函数的练习]
35.slider
	TODO[作为一个封装函数的练习]
36.拖放排序[TODO]
37.popWindow[TODO]
38.Ajax
	"url?" + Math.random();
	问题:
		前进，后退会失效
	1>XMLHttpRequest对象[>= IE7]
		new XMLHttpRequest();	//>= IE7
		new ActiveXObject("Msxml3.XMLHTTP");	//IE6
		new ActiveXObject("Msxml2.XMLHTTP");	//IE6
		new ActiveXObject("Microsoft.XMLHTTP");	//IE6

	2>XMLHttpRequest对象参考
		属性：
		onreadystatechange*:	指定当readyState属性改变时的事件处理句柄。只写	//*表示是W3C文档对象模型的扩展
			注：这是一个监听函数啊
			eg:
			xhr.onreadystatechange = function(){
				//your code
			}
		readyState:		返回当前请求的状态，只读
			注：
				0(未初始化)：对象已建立，但是尚未初始化[尚未调用open方法]
				1(初始化)：  对象已建立，尚未调用send方法
				2(发送数据)：send方法以调用，当时当前的状态及http头未知
				3(数据发送中)：以接受部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出错
				4(完成):	 数据接收完毕，此时可以通过responseBody和responseText获取完整的回应数据
		responseBody:	以unsigned byted数组形式返回，只读
		responseStream:	以Ado Stream对象的形式返回相应信息，只读
		responseText:	以字符串形式返回，只读
		responseXML:	以XML Document对象形式返回，只读
			可以指定编码
			?xml ... encoding="UTF-8"
		status:			返回当前请求的http状态码，只读
			注：
				100: Continue
				101: Switching protocols
				200: OK
				201: Created
				202: Accepted
				203: Non-Authoritative Information
				204: No Cotent
				205: Reset Content
				206: Partial Content
				300: Multiple Choices
				301: Moved Permanently
				302: Found
				303:See Other
				304: Not Modified
				305: Use Proxy
				307: Temporay Redirect
				400: Bad Request
				401: Unauthorized
				402: Payment Required
				403: Forbidden
				404：Not Fount
				405: Method Not Allowed
				406: Not Acceptable
				407: Proxy Authentication Required
				408: Request Timeout
				409: Conflict
				410: Gone
				411: Length Required
				412: Precondition Failed
				413: Request Entity Too Large
				414: Request-URI Too Long
				415: Unsupported Media Type
				416: Requested Range Not Suitable
				417: Expectation Failed
				500: Internal Server Error
				501: Not Implemented
				502: Bad Gateway
				503: Service Unavailable
				504: Gateway Timeout
				505: HTTP Version Not Supported
		statusText:		放回当前请求的相应行状态，只读
		方法：
		abort:取消当前请求
		getAllResponseHeaders:获取相应的所有http头
		getResponseHeader:从响应信息中获得指定的http头
			eg:
				xhr.getResponseHeader("Content-header");
		open:创建一个新的http请求，并指定此请求的方法、URL以及验证信息(用户名/密码)
			xhr.open(get/post, url, isAsync, username, password);
		send:发送请求到http服务器并接受回应
		setRequestHeader:单独指定请求的某个http头
		注：
			POST发送请求时参数设置
			xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
			数据放在send当中
			xhr.send(key=value&key2=value2);
	3>常见问题
		1>>缓存，添加动态字符串
		2>>乱码，
			html:meta:charset
			java:
			JSP:
			JS:
		3>>跨域访问问题
			html:
				<script src="javascript:;" id="remoteScript"></script>
			js:
				var rs = $("#remoteScript");
				var script = $("<script></script>");
				script.attr("src", "http:///todo");
				rs.parent().replaceWith(script);
				script.attr("id", "remoteScript");
	4>分页实例[面向对象的思维]
		返回的数据格式:
		{
			totalCount:100,
			rowData:[
				{cms_title:todo, cms_data:todo},
				{cms_title:todo, cms_data:todo}
			]
		}
		/**
		 * handler 回调函数
		 * url 服务器脚本位置
		 * pageSize 分页
		 * cols 列名
		 * order 排序
		 * dir ASC/DESC
		 */
		function AjaxPager(){

		}
		AjaxPager.prototype = {
			loadNextPage:function(){
			},
			loadPrevPage:function(){
			},
			loadPage:function(specPage, callback){
				Base.ajax({
					url:"todo",
					success:function(){
						var data= eval("(" + this.reponseText + ")");
						callback(data);
					}
				});
			},
			setPageSize:function(){}
		}

		var ajaxPage = new AjaxPager(data);
		ajaxPage.loadPage(1, function(){
			//callback exec
		});
39.FirebugLite[为没有firebug的浏览器实现的在线调试工具]
	console.log();
	console.warn();
	console.debug();
	console.info();
	console.dir();//遍历对象属性
	
	信息分组[开始的地方]
	console.group('任务一');
	console.groupEnd();
	
	占位符
	console.log("%d年%d月%d日",2011,3,26);
	
	//查看对象的信息
	console.dir(info);
	
	//显示某个节点的内容
	console.dirxml(info);
	
	//判断变量是否是真
	console.assert(year == 2018 );
	
	//打印函数的调用轨迹
	function add(a,b){
   console.trace();
	　return a+b;
	}
	var x = add3(1,1);
	function add3(a,b){return add2(a,b);}
	function add2(a,b){return add1(a,b);}
	function add1(a,b){return add(a,b);}

	url:http://getfirebug.com/firebuglite
	url:javascript:(function(F,i,r,e,b,u,g,L,I,T,E){if(F.getElementById(b))return;E=F[i+'NS']&&F.documentElement.namespaceURI;E=E?F[i+'NS'](E,'script'):F[i]('script');E[r]('id',b);E[r]('src',I+g+T);E[r](b,u);(F[e]('head')[0]||F[e]('body')[0]).appendChild(E);E=new%20Image;E[r]('src',I+L);})(document,'createElement','setAttribute','getElementsByTagName','FirebugLite','4','firebug-lite.js','releases/lite/latest/skin/xp/sprite.png','https://getfirebug.com/','#startOpened');
	上述为在线版
	注：
		可以下载离线版，把地址改为本地的连接就可以了
40.压缩JS
	1>
		URL:http://dean.edwards.name/packer/
		压缩变量名：Shrink variables
	2>
		closure-compiler
		cmd进入jar包所在目录
		java -jar compiler.jar --help
		java -jar compiler.jar --compilation_level ADVANCED_OPTIMIZATIONS --js base.js --js_output_file basec.js
	3>
		ESC 压缩
		cmd语法
		cscript esc.wsf --help
		cscript esc.wsf -l 4 base.js -ow basec.js
41.jQuery
	1>2个全局变量
		jQuery, $
	2>obj.appendTo(document.body);
	3>对象属性copy
	jQuery.extend(dest, origin);
	4>选择符
		selector:not(.className)
		:even  奇数行[0, 2, 4]
		:odd  偶数行[1, 3, 5]
		:nth-child(index)
	5>浏览器原生的事件对象
		evt.originalEvent
	6>this指针的传递
		fn.call(this, evt, nodes);
	7>事件委派
		live
			缺点：仅对有selector的jQuery对象有用
	8>链式调用
		不需要返回值时返回Jquery对象本身
	9>返回的集合元素
		可以使用.push()方法//类似于数组
	10>fx循环调用
	fx("slideDown", "slideUp");
	function fx(fn1, fn2){
		$(".logo")[fn1](1000, function(){
			$(".logo")[fn2](1000, function(){
				fx(fn1, fn2);
			});
		});
	}


------------面向对象创建对象的方法-------------------------
var Cat = {
　　createNew: function(){
　　　　var cat = {};
　　　　cat.name = "大毛";
　　　　cat.makeSound = function(){ alert("喵喵喵"); };
　　　　return cat;
　　}
};

var cat1 = Cat.createNew();
　   cat1.makeSound(); // 喵喵喵

-------------------------12种不宜使用的Javascript语法---------------------
1.推荐使用===和!==
	不推荐==和!=[之间的转化会很复杂]
2.with[不推荐]
with(obj) {
　　a = b;
　　c = d;
}
先判断obj.b和obj.d是否存在，如果不存在的话，再判断全局变量b和d是否存在[可能会出意外]
3.eval[不推荐]
	有性能和安全性的问题，并且使得代码更难阅读。
	eval("myValue = myObject." + myKey + ";");
	可以直接写成
　    myValue = myObject[myKey];
	至于ajax操作返回的json字符串，可以使用官方网站提供的解析器json_parse.js运行。
4.continue[不推荐]
	适当的命令可以避免这种写法
5.位运算符
	运算符针对的是整数，所以对Javascript完全无用，因为Javascript内部，所有数字都保存为双精度浮点数
6.function语句
	function foo() { }
	var foo = function () { }
	建议定义函数时，全部采用后一种写法。
7.基本数据类型的包装对象
	new String("Hello World");
　   new Number(2000);
　    new Boolean(false);
	这样写完全没有必要，而且非常费解，因此建议不要使用。
	new Object和new Array也不建议使用，可以用{}和[]代替。
8.new对象
	传统写法：
	var Cat = function (name) {
　　　　this.name = name;
　　　　this.saying = 'meow' ;
	}
	var myCat = new Cat('mimi');
	推荐写法：
	Object.beget = function (o) {
　　　　var F = function (o) {};
　　　　F.prototype = o ;
　　　　return new F;
	};
	var Cat = {
　　　　name:'',
　　　　saying:'meow'
	};
	var myCat = Object.beget(Cat);
	myCat.name = 'mimi';

--------------------------慕课网原生JavaScript学习--------------------------
■document
	属性：
	cookie			设置或返回与当前文档有关的所有 cookie。
	domain			返回当前文档的域名。
	lastModified	返回文档被最后修改的日期和时间。
	referrer		返回载入当前文档的文档的 URL。
	title			返回当前文档的标题。
	URL			返回当前文档的 URL。
■核心
	nodelist.item()	返回 NodeList 中位于指定下标的节点。
	nodelist.length	返回 NodeList 中的节点数。

■属性-属性
	element.id	设置或返回元素的 id。
	element.attributes	返回元素属性的 NamedNodeMap，包含一个NamedNodeMap，与NodeList类似[太麻烦，主要是遍历属性的时候使用]
		element.attributes[attName].nodeValue
		element.attributes[attName].nodeValue = '自定义数值'
	element.className	设置或返回元素的 class 属性
	element.classList.add(className);
	element.classList.remove(className);
	element.setAttribute()	把指定属性设置或更改为指定值。
	element.getAttribute(attName)	返回元素节点的指定属性值
	element.removeAttribute()	从元素中移除指定属性。
	element.setAttributeNode(attName, attVal)	设置或更改指定属性节点。
	element.getAttributeNode(attName)	返回指定的属性节点
	element.removeAttributeNode()	移除指定的属性节点，并返回被移除的节点。
	element.nodeName	返回元素的名称。
	element.tagName	返回元素的标签名。
	element.nodeType	返回元素的节点类型。
		节点类型		数值常量		字符常量
		Element(元素节点)	1			ELEMENT_NODE
		Attr(属性节点)		2			ATTRIBUTE_NODE
		Text(文本节点)	3			TEXT_NODE
		Comment(注释节点)	8			COMMENT_NODE

	element.nodeValue	设置或返回元素值。
	element.title	设置或返回元素的 title 属性。
	属性判定：
		attr.isId	如果属性是 id 类型，则返回 true，否则返回 false。
		attr.name	返回属性的名称。
		attr.value	设置或返回属性的值。
		nodemap.item()	返回 NamedNodeMap 中位于指定下标的节点。
		nodemap.length	返回 NamedNodeMap 中的节点数。
		nodemap.removeNamedItem()	移除指定的属性节点。
		nodemap.setNamedItem()	设置指定的属性节点（通过名称）。
■属性-CSS类
	element.style	设置或返回元素的 style 属性。
■属性-HTML代码/文本/值
	element.innerHTML	设置或返回元素的内容。
	element.innerText[IE下会解析标签]
	element.textContent[FF下忽略标签，但是按照代码的编写样式进行显示]
	element.outerHTML
	element.outerText

■CSS-CSS
■CSS-位置
	element.offsetParent	返回元素的偏移容器[元素的第一个祖先定位元素，用来计算offsetLeft，offsetTop(不一定与parentNode相等)]。
				注：在IE和Opera浏览器下，position: fixed的元素没有offsetParent
	element.offsetLeft	返回元素的水平偏移位置。
	element.offsetTop	返回元素的垂直偏移位置。
	element.scrollTop	返回元素上边缘与视图之间的距离。[元素被隐藏的上方的距离]
	element.scrollLeft	返回元素左边缘与视图之间的距离。
	document.documentElement.scrollTop 垂直方向滚动的值
■CSS-尺寸
	element.scrollWidth	返回元素的实际宽度。[元素内容 + 内边距(包括滚动条)]
	element.scrollHeight	返回元素的实际高度。
	eg:
	document.body.scrollWidth　　　document.body.scrollHeight
	1.给定宽高小于浏览器窗口
	scrollWidth和scrollHeight通常是此浏览器窗口的宽高

	2.给定宽高大于浏览器窗口，且子元素小于给定宽高
	宽高为设定的宽高+padding*2+border*2

	3.给定宽高大于浏览器窗口，且内容大于给定宽高
	宽高为子元素的宽高 +body的padding[1个]+margin[1个]+border[1个]

	[无滚动轴时]
	scrollWidth = clientWidth = style.width + style.padding * 2 
	[有滚动轴时]
	scrollWidth = 实际内容的宽度 + padding * 2
	scrollHeight = 实际内容的高度 + padding * 2


	element.clientWidth	返回元素的可见宽度。[元素内容 + 内边距(不包括滚动条)]
	element.clientHeight	返回元素的可见高度。
	element.offsetHeight	返回元素的高度。[元素内容 + 内边距 + 边框(不包括外边距)]
	element.offsetWidth	返回元素的宽度。
	element.innerWidth	返回元素内部的宽高，包括padding，不包括border
	element.outerWidth	返回元素集合中第1个元素当前计算宽高度值，包括padding，border，选择性的margin
				window.outerWidth表示整个浏览器窗体的大小，包括任务栏等[IE9+]
	element.outerHeight
				window.outerHeight表示整个浏览器窗体的大小，包括地址栏，收藏栏，标签栏，任务栏等[IE9+]
■创建元素节点
	document.crateAttribute(name)：　　　　　 　　用指定名称name创建特性节点
	document.createComment(text)：　　　　　　　创建带文本text的注释节点
	document.createDocumentFragment()：　　　　创建文档碎片节点[防止页面多次刷新]
	document.createElement(tagname)：　　　　　  创建标签名为tagname的节点
	document.createTextNode(text)：　　　　　　   创建包含文本text的文本节点
■选择器-基本
	element.getElementById()	返回对拥有指定 id 的第一个对象的引用。
	element.getElementsByClassName()	返回对拥有指定class数组。
	element.getElementsByTagName()	返回拥有指定标签名的所有子元素的集合[HTMLCollection与NodeList非常相似]。
		htmlCollection.nameItem(nameVal);可以获得指定元素的对象
		htmlCollection[nameVal]		同上边等价
	element.getElementsByName()	返回带有指定名称的对象集合[HTMLCollection与NodeList非常相似]。
	document.forms == document.getElementsByTagName('form')		返回带有指定名称的对象集合[HTMLCollection与NodeList非常相似]
		document.forms[0]		取得第一个表单元素的内容
		document.froms[formName]
		document.froms[formName].elements[表单中所有元素的集合][推荐的使用方法]
		document.froms[formName].elements[0]
		document.froms[formName].elements[elementName]		名字相同的控件radio会返回一个NodeList
		document.images
		document.links
	element.querySelector();
	element.querySelectorAll();
■选择器-层级
■选择器-基本
■选择器-内容
■选择器-可见性
■选择器-属性
■选择器-子元素
■选择器-表单
■选择器-表单对象属性

■文档处理-内部插入
	element.appendChild(newNode)	向元素添加新的子节点，作为最后一个子节点[返回新增的子节点(如果该节点在文档中已经存在，就把改节点移动到现在的位置)]。
■文档处理-外部插入
	element.insertBefore(newNode, refNode)	在指定的已有的子节点之前插入新节点。
■文档处理-包裹
■文档处理-替换
	element.replaceChild(newChild, oldChild)		替换元素中的子节点。
■文档处理-删除
	element.removeChild(oldNode)	从元素中移除子节点[返回被删除的节点oldNode]。
■文档处理-复制
	element.cloneNode(booleanFlag)	克隆元素[是否进行深复制(这个节点就是个孤儿节点)]。

■筛选-过滤
	element.hasAttribute()	如果元素拥有指定属性，则返回true，否则返回 false。
	element.hasAttributes()	如果元素拥有属性，则返回 true，否则返回 false。
	element.hasChildNodes()	如果元素拥有子节点，则返回 true，否则 false。
■筛选-查找
	element.childNodes	返回元素子节点的 NodeList[类数组对象]。
	element.parentNode	返回元素的父节点。
	element.firstChild	返回元素的首个子。
	element.lastChild	返回元素的最后一个子元素。
	element.previousSibling	返回位于相同节点树层级的前一个元素[同胞节点]。
	element.nextSibling	返回位于相同节点树层级的下一个节点[同胞节点]。
	element.ownerDocument	文档根节点[比较直接，省去层层的麻烦]
	document.doctype	获得对<!DOCTYPE>的引用
■筛选-串联

■事件-页面载入
■事件-事件处理
■事件-事件委派
■事件-事件切换
■事件-事件-句柄
	onblur			元素失去焦点。
	onchange		域的内容被改变。
	onclick			当用户点击某个对象时调用的事件句柄。
	ondblclick		当用户双击某个对象时调用的事件句柄。
	onerror			在加载文档或图像时发生错误。
	onfocus			元素获得焦点。
	onkeydown		某个键盘按键被按下。
	onkeypress		某个键盘按键被按下并松开。
	onkeyup			某个键盘按键被松开。
	onload			一张页面或一幅图像完成加载。
	onmousedown		鼠标按钮被按下。
	onmousemove		鼠标被移动。
	onmouseout		鼠标从某元素移开。
	onmouseover		鼠标移到某元素之上。
	onmouseup		鼠标按键被松开。
	onreset			重置按钮被点击。
	onresize		窗口或框架被重新调整大小。
	onselect		文本被选中。
	onsubmit		确认按钮被点击。
	onunload		用户退出页面。
■效果-基本

■工具-浏览器及特性检测
■工具-数组和对象操作
■工具-函数操作
■工具-字符串操作
	.toUpperCase()
	.toLowerCase()
■事件对象
	altKey	返回当事件被触发时，"ALT" 是否被按下。[true|false]
	button	返回当事件被触发时，哪个鼠标按钮被点击。[012 左中右]
	clientX	返回当事件被触发时，鼠标指针的水平坐标。
	clientY	返回当事件被触发时，鼠标指针的垂直坐标。
	ctrlKey	返回当事件被触发时，"CTRL" 键是否被按下。
	metaKey	返回当事件被触发时，"meta" 键是否被按下。
	relatedTarget	返回与事件的目标节点相关的节点。
	screenX	返回当某个事件被触发时，鼠标指针的水平坐标(相对于电脑屏幕)。[IE9+]
	screenY	返回当某个事件被触发时，鼠标指针的垂直坐标。[IE9+]
	eg:
		window.screenX	浏览器窗口在显示器中距离左边的位置
		window.screenY	浏览器窗口在显示器中距离顶部的位置
	eg:[都是可见距离包括工具栏(又包含的有不包含的)]
		//[浏览器距离左边的距离]
		var leftPos = (typeof window.screenLeft === 'number')?window.screenLeft:window.screenX;
		//[浏览器距离顶部的距离]
		var topPos = (typeof window.screenTop === 'number')?window.screenTop:window.screenY;
	window.screen.width
	window.screen.height 		显示器的宽高[IE5.5+][包括任务栏的高度差]
	shiftKey	返回当事件被触发时，"SHIFT" 键是否被按下。
	window.screen.availWidth和window.screen.availHeight
	显示器可用宽高，不包括任务栏之类的东东
	eg:
		screen.availWidth
		screen.availHeight
	window.screenLeft
	window.screenTop
	释义:浏览器窗口相对于屏幕左边和顶部的距离
■普通函数

■Touch基础事件[移动mobile手机事件]
	触摸才是移动设备的交互的核心事件
	touchstart:手指触摸屏幕触发(已经有手指放屏幕上不会触发)
	touchmove:手指在屏幕滑动，连续触发
	toucheend:手指离开屏幕时触发
	touchcancel:系统取消touch时候触发(不常用)

■除常见的事件属性外，触摸事件包含专有的触摸属性
	touches:跟踪触摸操作的touch对象数组
	targetTouches:特定事件目标的touch对象数组
	changeTouches:上次触摸改变的touch对象数组

■Touch基础事件
	每个touch对象包含属性[根据touch对象跟踪触摸具体位置从而判断触摸交互或手势事件]：
	clientX:触摸目标在视口中的x坐标
	clientY:触摸目标在视口中的y坐标
	identifier:标识触摸的唯一ID
	pageX:触摸目标在页面中的x坐标(包含滚动)
	pageY:触摸目标在页面中的y坐标(包含滚动)
	screenX:触摸目标在屏幕中的x坐标
	screenY:触摸目标在屏幕中的y坐标
	target:触摸DOM节点目标

■Android bug
	bug:Android只会触发一次touchstart，一次touchmove，touchend不触发
	解决方案:在touchmove中加入：event.preventDefault(),可fixed Bug
	副作用:event.preventDefault()会导致默认行为不发生，如scroll,导致页面不滚动

加载IE6-IE8中的脚本文件
	if (!document.addEventListener) {
	    // IE6~IE8
	    document.write('<script src="ieBetter.js"><\/script>');
	}

■文档视图(DocumentView)和元素视图(ElementView)方法
	1>elementFromPoint()[IE5.5+]
		返回给定坐标处所在的元素
		这个方法可以用来检测元素是否发生重叠或是碰撞
	2>getBoundingClientRect()[IE5.5+][元素距离页面顶部的距离]
		得到矩形元素的界线
		返回内容类似于：{top:143, right:1196, bottom:164, left:889 }

	jQuery对应部分
	.offset()
	{left:相对于body左上角的距离，top:相对于body顶部的距离}
	注：这个只有2个值，getBoundingClientRect()有4个值
	3>getClientRects()[IE8+]
		返回元素的数个矩形区域，返回的结果是个对象列表，具有数组特性。这里的矩形选区只针对inline box
	4>scrollIntoView()
		让元素滚动到可视区域
■滚轮事件
	FF派和其他派
	document.body.addEventListener("DOMMouseScroll", function(event) {
	    console.dir(event);
	});
	document.body.onmousewheel = function(event) {
	    event = event || window.event;
	    console.dir(event);
	};
	鼠标滚动事件与点击事件有很多类似的地方
	eg:
	event.type,	event.screenX/event.screenY,		event.clientX/event.clientY
	event.altKey	event.shiftKey		event.cancelBubble

■ECMAScript5.1
	支持情况如下：
	Opera 11.60
	Internet Explorer 9*	[IE9不支持严格模式 — IE10 添加]
	Firefox 4
	Safari 5.1**	[Safari 5.1 仍不支持 Function.prototype.bind]
	Chrome 13
	完整的兼容表格如下：
	http://kangax.github.io/compat-table/es5/

	开启严格模式[提供额外的安全性]：
	"use strict";
	function strict(){
	  "use strict";
	  //...
	}

	function sloppy(){
	  eval("window.foo = 'bar'");
	}

	JSON[json2.js可以使低版本的浏览器具有ES5相同的JSON功能]
	JSON全局对象
	JSON.stringify序列化，把JSON对象转化成字符串
	JSON.parse反序列化，把字符串转化成JSON对象
	eg:
		>>var result = JSON.parse('{"a": 1, "b": "2"}');
		Object
		>>result.b
		"2"

	JSON.parse(text [, reviver])
		该可选的reviver参数是有带有key和value两个参数的函数，其作用于结果——让过滤和转换返回值成为可能。
		eg:
		var result = JSON.parse('{"a": 1, "b": "2"}', function(key, value){
		  if (typeof value == 'string'){
		    return parseInt(value);
		  } else {
		    return value;
		  }
		})
		>> result.b
		2

	JSON.stringify(value [, replacer [, space]])
	eg:
	>>> var mike = JSON.stringify({mike: "taylor"})
	undefined
	>> typeof mike
	"string"

	replacer函数，是过滤函数
	var nums = {
	  "first": 7,
	  "second": 14,
	  "third": 13
	}

	var luckyNums = JSON.stringify(nums, function(key, value){
	  if (value == 13) {
	    return undefined;
	  } else {
	    return value;
	  }
	});

	>> luckyNums
	'{"first": 7, "second": 14}'

	space[number]，作缩进的JSON字符串或字符串每个水平上缩进的空格数，超过10个按10个处理
	 var luckyNums = JSON.stringify(nums, function(key, value) {
	  if (value == 13) {
	    return undefined;
	  } else {
	    return value;
	  }
	}, 2);

	>> luckyNums
	'{
	  "first":7,			//空格缩进2格
	  "second":14
	}'

	Function.prototype.bind(thisArg [, arg1 [, arg2, …]])
	Function.prototype.bind返回一个新的函数对象
	该函数对象的this绑定到了thisArg参数上。从本质上讲，这允许你在其他对象链中执行一个函数。
	俗话：Function对象的this指针指向thisArg函数。
	兼容：
	if (!function() {}.bind) {
	    Function.prototype.bind = function(context) {
	        var self = this, args = Array.prototype.slice.call(arguments);

	        return function() {
	            return self.apply(context, args.slice(1));
	        }
	    };
	}


1.条件表达式会强制进行布尔值转化
参数类型		    false			true
Undefined		       √
Number		  ±0,NaN		  √
String			        ""			  √
Object			      null			  √

2.双等号等价判断
Type(x)				Type(y)				Result
null                                      Undefined                         true
Undefined                          null                                     true
Number                              String                                 x == toNumber(y)
String                                  Number                             toNumber(x) == y
Boolean                              any                                      toNumber(x) == y
any                                       Boolean                             x == toNumber(y)
String or Number            Object                                x == toPrimitive(y)
Object                                  String or Number          toPrimitive(x) == y
其他                                     其他                                   false

ToNumber[转化为数字]
参数类型                             结果
Undefined                           NaN
Null                                       0
Boolean                               参数是true结果为1
                                               参数是false结果为0
Number                               不用转化
String                                   效果等价于Number(string)
                                               "abc" --> NaN
                                               "123" --> 123
Object                                   通过以下2个步骤进行转换
                                               1.toPrimitive(inputParam, preferredType)转化为原始值
                                               preferredType[Number|String]:代表了转换的偏好
                                               if(Number){
	                                               1>如果输入的值已经是个原始值,则直接返回它
	                                               2>否则,如果输入的值是一个对象.则调用该对象的valueOf()方法.如果valueOf()方法的返回值是一个原始值,则返回这个原始值.
	                                               3>否则,调用这个对象的toString()方法.如果toString()方法的返回值是一个原始值,则返回这个原始值.
	                                               4>否则,抛出TypeError异常.
                                               }else if(String){
                                                       1>调用这个对象的toString()方法.如果toString()方法的返回值是一个原始值,则返回这个原始值.
                                                       2>否则,如果输入的值是一个对象.则调用该对象的valueOf()方法.如果valueOf()
                                               }else{
                                                       Date类型的对象会被设置为String,其它类型的值会被设置为Number
                                               }
                                               2.toNumber()将这个原始值转化为数字

ToPrimitive()[转化为原始值]
参数类型                             结果
Object                                   通过以下3个步骤进行转换
                                               1.valueOf()
                                               2.toString()
                                               3.an error
其他情况                             不用转换

ToString()[转化为字符串]
参数类型                             结果
Undefined                            "undefined"
Null                                         "null"
Boolean                                 "true" | "false"
Number                                  转化为字符串
String                                      不用转换
Object                                     通过以下2个步骤进行转换
                                                 1.toPrimitive(obj, String)转化为原始值
                                                 2.toString()将这个原始值转化为字符串

有下面这样的一个加法操作.
    value1 + value2
    在计算这个表达式时,内部的操作步骤是这样的

    将两个操作数转换为原始值
        prim1 := ToPrimitive(value1)
        prim2 := ToPrimitive(value2)
    PreferredType被省略,因此Date类型的值采用String,其他类型的值采用Number.
    如果prim1或者prim2中的任意一个为字符串,则将另外一个也转换成字符串,然后返回两个字符串连接操作后的结果.
    否则,将prim1和prim2都转换为数字类型,返回他们的和.

总结：先转数字再转字符串

严格相等===
类型                                       值                                  结果
Undefined或者Null                                                 true
Number                               NaN                               false
String                                    相同的字符串            true
Boolean                               同为true或false         true
Object                                   引用相同时                 true
其他情况                                                                     false

■H5本地存储
可以存储[数组，json数据，图片，脚本，样式文件]
localstorage API介绍
getItem
	localStorage.getItem('key1')
setItem
	localStorage.setItem('key1','value1')
removeItem
key
	localStorage.key(0)
clear
	localStorage.clear()

■WebSql和IndexedDB


█jQuery相关部分
.width() || .height()
释义:只包含content的净宽高，不包括margin,border,padding

.width()与.css('width')区别
.width()返回结果无单位
.css('width')的结果有单位

.innerWidth() || .innerHeight()
释义:content + padding

.outerWidth() || .outerHeight()
释义:content + padding + border

.outerWidth(true) || .outerHeight(true)
释义:content + padding + border + margin


